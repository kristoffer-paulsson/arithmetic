/**
 * Reference arithmetic coding
 *
 * Copyright (c) 2025 by Kristoffer Paulsson <kristoffer.paulsson@talenten.se>.
 *
 * Copyright (c) Project Nayuki
 * MIT License. See readme file.
 * https://www.nayuki.io/page/reference-arithmetic-coding
 *
 *      https://opensource.org/licenses/MIT
 *
 * SPDX-License-Identifier: MIT
 *
 * Contributors:
 *      Nayuki - initial Java implementation
 *      Kristoffer Paulsson - porting and adaption to Kotlin for alternative use
 */
package org.example.arithmetic

import java.io.BufferedInputStream
import java.io.BufferedOutputStream
import java.io.File
import java.io.FileInputStream
import java.io.FileOutputStream
import java.io.IOException
import java.io.OutputStream


/**
 * Decompression application using adaptive arithmetic coding.
 *
 * Usage: java AdaptiveArithmeticDecompress InputFile OutputFile
 *
 * This decompresses files generated by the "AdaptiveArithmeticCompress" application.
 */
public object AdaptiveArithmeticDecompress {
    @Throws(IOException::class)
    public fun main(args: Array<String>) {
        // Handle command line arguments
        if (args.size != 2) {
            System.err.println("Usage: java AdaptiveArithmeticDecompress InputFile OutputFile")
            System.exit(1)
            return
        }
        val inputFile: File = File(args[0])
        val outputFile: File = File(args[1])

        BitInputStream(BufferedInputStream(FileInputStream(inputFile))).use { `in` ->
            BufferedOutputStream(FileOutputStream(outputFile)).use { out ->
                decompress(`in`, out)
            }
        }
    }


    // To allow unit testing, this method is package-private instead of private.
    @Throws(IOException::class)
    public fun decompress(`in`: BitInputStream, out: OutputStream) {
        val initFreqs: FlatFrequencyTable = FlatFrequencyTable(257)
        val freqs: FrequencyTable = SimpleFrequencyTable(initFreqs)
        val dec: ArithmeticDecoder = ArithmeticDecoder(32, `in`)
        while (true) {
            // Decode and write one byte
            val symbol: Int = dec.read(freqs)
            if (symbol == 256)  // EOF symbol
                break
            out.write(symbol)
            freqs.increment(symbol)
        }
    }
}
