/*
* Reference arithmetic coding
*
* Copyright (c) Project Nayuki
* MIT License. See readme file.
* https://www.nayuki.io/page/reference-arithmetic-coding
*/
package org.example.arithmetic

import java.io.BufferedInputStream
import java.io.BufferedOutputStream
import java.io.File
import java.io.FileInputStream
import java.io.FileOutputStream
import java.io.IOException
import java.io.OutputStream
import java.util.Arrays

/**
 * Decompression application using prediction by partial matching (PPM) with arithmetic coding.
 *
 * Usage: java PpmDecompress InputFile OutputFile
 *
 * This decompresses files generated by the "PpmCompress" application.
 */
public object PpmDecompress {
    // Must be at least -1 and match PpmCompress. Warning: Exponential memory usage at O(257^n).
    private const val MODEL_ORDER = 3


    @Throws(IOException::class)
    public fun main(args: Array<String>) {
        // Handle command line arguments
        if (args.size != 2) {
            System.err.println("Usage: java PpmDecompress InputFile OutputFile")
            System.exit(1)
            return
        }
        val inputFile: File = File(args[0])
        val outputFile: File = File(args[1])

        BitInputStream(BufferedInputStream(FileInputStream(inputFile))).use { `in` ->
            BufferedOutputStream(FileOutputStream(outputFile)).use { out ->
                decompress(`in`, out)
            }
        }
    }


    // To allow unit testing, this method is package-private instead of private.
    @Throws(IOException::class)
    public fun decompress(`in`: BitInputStream, out: OutputStream) {
        // Set up decoder and model. In this PPM model, symbol 256 represents EOF;
        // its frequency is 1 in the order -1 context but its frequency
        // is 0 in all other contexts (which have non-negative order).
        val dec: ArithmeticDecoder = ArithmeticDecoder(32, `in`)
        val model: PpmModel = PpmModel(MODEL_ORDER, 257, 256)
        var history = IntArray(0)

        while (true) {
            // Decode and write one byte
            val symbol = decodeSymbol(dec, model, history)
            if (symbol == 256)  // EOF symbol
                break
            out.write(symbol)
            model.incrementContexts(history, symbol)

            if (model.modelOrder >= 1) {
                // Prepend current symbol, dropping oldest symbol if necessary
                if (history.size < model.modelOrder) history = Arrays.copyOf(history, history.size + 1)
                System.arraycopy(history, 0, history, 1, history.size - 1)
                history[0] = symbol
            }
        }
    }


    @Throws(IOException::class)
    private fun decodeSymbol(dec: ArithmeticDecoder, model: PpmModel, history: IntArray): Int {
        // Try to use highest order context that exists based on the history suffix. When symbol 256
        // is consumed at a context at any non-negative order, it means "escape to the next lower order
        // with non-empty context". When symbol 256 is consumed at the order -1 context, it means "EOF".
        outer@ for (order in history.size downTo 0) {
            var ctx: PpmModel.Context = model.rootContext
            for (i in 0..<order) {
                if (ctx.subcontexts.isEmpty()) throw AssertionError()
                ctx = ctx.subcontexts[history[i]]
                if (ctx === PpmModel.nullCtx) continue@outer
            }
            val symbol: Int = dec.read(ctx.frequencies)
            if (symbol < 256) return symbol
            // Else we read the context escape symbol, so continue decrementing the order
        }
        // Logic for order = -1
        return dec.read(model.orderMinus1Freqs)
    }
}
